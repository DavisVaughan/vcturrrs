% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/map.R
\name{vec_map}
\alias{vec_map}
\title{Apply a function to each element of a vector}
\usage{
vec_map(.x, .f, ..., .ptype = NULL)
}
\arguments{
\item{.x}{A list or atomic vector.}

\item{.f}{A function, formula, or vector (not necessarily atomic).

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function. There
are three ways to refer to the arguments:
\itemize{
\item For a single argument function, use \code{.}
\item For a two argument function, use \code{.x} and \code{.y}
\item For more arguments, use \code{..1}, \code{..2}, \code{..3} etc
}

This syntax allows you to create very compact anonymous functions.

If \strong{character vector}, \strong{numeric vector}, or \strong{list}, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of \code{.default} will be returned.}

\item{...}{Additional arguments passed on to the mapped function.}

\item{.ptype}{A prototype for the output container. If \code{NULL}, a common
type is determined from the individual results of the \code{map()}. If no
common type can be determined, the output container is a \code{list()}.}
}
\description{
\code{vec_map()} is like \code{\link[purrr:map]{purrr::map()}}, but can automatically simplify the output
based on vctrs type rules. This does away with the need for variants such
as \code{map_dbl()}, and is more expressive because the output type can be
anything, for example, a \code{Date} vector.
}
\details{
If \code{.ptype = NULL}, the common type of the results of the \code{map()} will
attempt to be determined. If a common type can be found, then the result
will be simplified to that type. Otherwise, a list is returned.

If a common type is found, it is a requirement that every element have
size \code{1}. This enforces the invariant that the size of the input is the
same size as the output.

You can force an output type by specifying the \code{.ptype}. For example,
specifying \code{.ptype = double()} is equivalent to \code{map_dbl()}.

Setting \code{.ptype = list()} is equivalent to \code{map()}.
}
\section{Invariants}{


\code{vec_size(.x) == vec_size(vec_map(.x))}
}

\examples{

library(vctrs)

# Auto simplified to an integer vector
vec_map(1:2, ~ .x)

# Prevent simplification with `.ptype = list()`
vec_map(1:2, ~ .x, .ptype = list())

# If a `.ptype` is specified, and casting to that type
# is not possible, an error is raised
try(vec_map(1:2, ~ .x, .ptype = factor()))

# If simplification is possible, all elements must have size 1,
# otherwise an error is raised
try(vec_map(1:2, ~ if (.x == 1L) 1:2 else 3))

# But if you use `.ptype = list()`, this is relaxed
# (However, note that the size of the output is still the
# same as the size of the input (2), this is the key!)
vec_map(1:2, ~ if (.x == 1L) 1:2 else 3, .ptype = list())

# The best thing about `vec_map()` is its flexibility with other
# non-atomic types, for example, simplifying to a date vector
vec_map(1:2, ~ Sys.Date() + .x)

# If a common type cannot be determined, a list is returned
vec_map(list(1, "x"), ~ .x)

# Note that just because a common type isn't found, doesn't mean you
# can't still coerce to a certain type. This is the difference between
# _coercion_ (automatic type casting) and a _cast_ which is slightly more
# flexible because you are specifically requesting the output type.
vec_map(list(1, "x"), ~ .x, .ptype = character())

# Data frames work too
vec_map(1:2, ~ data.frame(x = .x))

# You can enforce the structure of the data frame output with a ptype.
# This has the same result as before but coerces the integers to characters
ptype <- data.frame(x = character(), stringsAsFactors = FALSE)
vec_map(1:2, ~ data.frame(x = .x), .ptype = ptype)

# Or you can enforce a partial structure with a partial_frame()
partial_ptype <- partial_frame(y = numeric())
vec_map(1:2, ~ data.frame(x = .x, y = .x + 1), .ptype = partial_ptype)

}
